%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function[output_image] = controlled_qubit_level_scrambling(P, image)
% Load your image (Assuming it's grayscale)
%image = imresize(image, [512 512]); % Resize if not already 512x512
output_image = image;
% Normalize P to be between 1 and 2
P = mod(P*100, 5);
P = round(P);
% Apply scrambling based on P values
for i = 1:numel(image)
    pixel = image(i);
    times_to_apply = P(i);
    
    if mod(times_to_apply, 2) == 0 % Even numbers including zero
        for j = 1:times_to_apply
            pixel = qubit_level_shift_operation(pixel);
        end
    else % Odd numbers
        for j = 1:times_to_apply
            pixel = quantumXORshift(pixel);
        end
    end
    
    output_image(i) = pixel;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % Parameters for chaotic sequence
% a = 3.72; b = 0.15; n = 512 * 512 * 5; % Adjust 'n' based on required sequence length
% cx = zeros(1, n); cy = zeros(1, n); cz = zeros(1, n);
% cx(1) = 0.21; cy(1) = 0.131; cz(1) = 0.128;
% 
% % Generate chaotic sequence
% for j = 1 : n-1
%     cx(j+1) = cos(a*cx(j))*sin(1/(cy(j)*(1-cz(j))^2));
%     cy(j+1) = sin(a*cx(j)*cy(j)+b*cz(j));
%     cz(j+1) = cx(j);
% end
% 
% % Initialize P sequence and normalize it
% P = [];
% k = 5; % Taking every fifth element
% seq_length = min([length(cx), length(cy), length(cz)]);
% for i = k:k:seq_length
%     P = [P, 1 + mod(cx(i), 1), 1 + mod(cy(i), 1), 1 + mod(cz(i), 1)];
% end
% P = round(P); % Round the values to 1 or 2